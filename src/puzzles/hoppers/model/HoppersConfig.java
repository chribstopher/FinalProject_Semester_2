package puzzles.hoppers.model;

import puzzles.common.solver.Configuration;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

// TODO: implement your HoppersConfig for the common solver

public class HoppersConfig implements Configuration{
    private static int rows;
    private static int columns;
    private char[][] graph;
    private int pieceCount;
    private int col;
    private int row;

    public HoppersConfig(String filename) throws IOException {
        try (BufferedReader in = new BufferedReader(new FileReader(filename))){
            //getting rows and column dimensions
            String[] dimensions = in.readLine().split("");
            this.rows = Integer.parseInt(dimensions[0]);
            this.columns = Integer.parseInt(dimensions[1]);
            this.graph = new char[rows][columns];
            //building the graph
            //piece count will be used for isSolution
            this.pieceCount = 0;
            for (int r = 0; r < rows; r++){
                String[] rowContents = in.readLine().split("");
                for (int c = 0; c < columns; c++){
                    char content = rowContents[c].charAt(0);
                    if (content == 'G' || content == 'R'){
                        this.pieceCount += 1;
                    }
                    this.graph[r][c] = content;
                }

            }
        }
    }

    /**
     * Copy constructor. Takes a config other, and makes a full copy of its
     * instance data
     * @param other the config to copy
     */
    private HoppersConfig(HoppersConfig other){
        this.rows = other.rows;
        this.columns = other.columns;
        this.graph = new char[rows][columns];
        this.pieceCount = other.pieceCount;
        //copying other graph
        for (int r = 0; r < rows; r++){
            for (int c = 0; c < columns; c++){
                this.graph[r][c] = other.graph[r][c];
            }
        }
    }

    /**
     * checks if the current configuration is the solution
     * @return true or false
     */
    @Override
    public boolean isSolution() {
        return this.pieceCount == 1;
    }

    /**
     * finds all the neighbor configurations for a given configuration
     * @return collection of all the neighbors
     */
    @Override
    public Collection<Configuration> getNeighbors() {
        List<Configuration> neighbors = new ArrayList<>();
        for (int r = 0; r < rows; r++){
            for (int c = 0; r < columns; c++){

            }
        }

    }

    /**
     * finds which moves can be generated by a given frog
     * @return collection of configurations representing valid moves
     */
    public Collection<Configuration> getMoves(){
        return null;
    }

    /**
     * checks to see if a given configuration is valid and if not,
     * prunes the configuration.
     * @return true or false
     */
    public boolean isValid(){
        return false;
    }

    /**
     * checks to see if a square on the grid contains a frog
     * @return true or false
     */
    public boolean isFrog(){
        return false;
    }
}
