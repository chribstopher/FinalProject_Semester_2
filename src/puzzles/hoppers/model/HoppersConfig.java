package puzzles.hoppers.model;

import puzzles.common.solver.Configuration;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;

// TODO: implement your HoppersConfig for the common solver

/**
 *
 * @author Christopher Rose
 */

public class HoppersConfig implements Configuration{
    private int rows;
    private int columns;
    private char[][] graph;
    private int pieceCount;

    public HoppersConfig(String filename) throws IOException {
        try (BufferedReader in = new BufferedReader(new FileReader(filename))){
            //getting rows and column dimensions
            String[] dimensions = in.readLine().split("");
            this.rows = Integer.parseInt(dimensions[0]);
            this.columns = Integer.parseInt(dimensions[2]);
            this.graph = new char[rows][columns];
            //building the graph
            //piece count will be used for isSolution
            this.pieceCount = 0;
            for (int r = 0; r < rows; r++){
                String[] rowContents = in.readLine().split(" ");
                for (int c = 0; c < columns; c++){
                    char content = rowContents[c].charAt(0);
                    if (content == 'G' || content == 'R'){
                        this.pieceCount += 1;
                    }
                    this.graph[r][c] = content;
                }

            }
        }
    }

    /**
     * Copy constructor. Takes a config other, and makes a full copy of its
     * instance data
     * @param other the config to copy
     */
    private HoppersConfig(HoppersConfig other){
        this.rows = other.rows;
        this.columns = other.columns;
        this.graph = new char[rows][columns];
        this.pieceCount = other.pieceCount;
        //copying other graph
        for (int r = 0; r < rows; r++){
            for (int c = 0; c < columns; c++){
                this.graph[r][c] = other.graph[r][c];
            }
        }
    }

    /**
     * checks if the current configuration is the solution
     * @return true or false
     */
    @Override
    public boolean isSolution() {
        int greenFrogs = 0;
        int redFrogs = 0;
        for (int r = 0; r < rows; r++){
            for (int c = 0; c < columns; c++){
                if (graph[r][c] == 'G'){
                    greenFrogs += 1;
                }
                if (graph[r][c] == 'R'){
                    redFrogs += 1;
                }
            }
        }
        return greenFrogs == 0 && redFrogs == 1;
    }

    /**
     * finds all the neighbor configurations for a given configuration
     * @return collection of all the neighbors
     */
    @Override
    public Collection<Configuration> getNeighbors() {
        List<Configuration> neighbors = new ArrayList<>();
        for (int r = 0; r < rows; r++){
            boolean oddRow = isOddRow(r);
            for (int c = 0; c < columns; c++){
                if (isFrog(r, c)){
                    List<Configuration> moves = getMoves(r, c, oddRow);
                    neighbors.addAll(moves);
                }
            }
        }
        return neighbors;
    }

    /**
     * finds which moves can be generated by a given frog
     * @return collection of configurations representing valid moves
     */
    public List<Configuration> getMoves(int r, int c, boolean oddRow){
        List <Configuration> moves = new ArrayList<>();

        if (r % 2 == 0){
            //8 moves that can be made
            //
            //top left jump
            if (r-2 >= 0 && c-2 >= 0 && this.graph[r-2][c-2] == '.'){
                HoppersConfig successor = new HoppersConfig(this);
                if (this.graph[r-1][c-1] == 'G'){
                    //removing frog that has been jumped over and decrementing
                    //piece count by 1
                    successor.graph[r-1][c-1] = '.';
                    successor.pieceCount -= 1;
                    //moving the frog to final position
                    successor.graph[r-2][c-2] = this.graph[r][c];
                    successor.graph[r][c] = '.';
                    moves.add(successor);
                }
            }
            //north jump
            if (r-4 >= 0 && this.graph[r-4][c] == '.'){
                HoppersConfig successor = new HoppersConfig(this);
                if (this.graph[r-2][c] == 'G'){
                    successor.graph[r-2][c] = '.';
                    successor.pieceCount -= 1;
                    successor.graph[r-4][c] = this.graph[r][c];
                    successor.graph[r][c] = '.';
                    moves.add(successor);
                }
            }
            //top right jump
            if (r-2 >= 0 && c+2 < this.columns && this.graph[r-2][c+2] == '.'){
                HoppersConfig successor = new HoppersConfig(this);
                if (this.graph[r-1][c+1] == 'G') {
                    successor.graph[r - 1][c + 1] = '.';
                    successor.pieceCount -= 1;
                    successor.graph[r - 2][c + 2] = this.graph[r][c];
                    successor.graph[r][c] = '.';
                    moves.add(successor);
                }
            }
            //west jump
            if (c-4 >= 0 && this.graph[r][c-4] == '.'){
                HoppersConfig successor = new HoppersConfig(this);
                if (this.graph[r][c-2] == 'G'){
                    successor.graph[r][c-2] = '.';
                    successor.pieceCount -= 1;
                    successor.graph[r][c-4] = this.graph[r][c];
                    successor.graph[r][c] = '.';
                    moves.add(successor);
                }
            }
            //east jump
            if (c+4 < this.columns && this.graph[r][c+4] == '.'){
                HoppersConfig successor = new HoppersConfig(this);
                if (this.graph[r][c+2] == 'G'){
                    successor.graph[r][c+2] = '.';
                    successor.pieceCount -= 1;
                    successor.graph[r][c+4] = this.graph[r][c];
                    successor.graph[r][c] = '.';
                    moves.add(successor);
                }
            }
            //bottom left jump
            if (r+2 < this.rows && c-2 >= 0 && this.graph[r+2][c-2] == '.'){
                HoppersConfig successor = new HoppersConfig(this);
                if (this.graph[r+1][c-1] == 'G'){
                    successor.graph[r+1][c-1] = '.';
                    successor.pieceCount -= 1;
                    successor.graph[r+2][c-2] = this.graph[r][c];
                    successor.graph[r][c] = '.';
                    moves.add(successor);
                }
            }
            //south jump
            if (r+4 < this.rows && this.graph[r+4][c] == '.'){
                HoppersConfig successor = new HoppersConfig(this);
                if (this.graph[r+2][c] == 'G'){
                    successor.graph[r+2][c] = '.';
                    successor.pieceCount -= 1;
                    successor.graph[r+4][c] = this.graph[r][c];
                    successor.graph[r][c] = '.';
                    moves.add(successor);
                }
            }
            //bottom right jump
            if (r+2 < this.rows && c+2 < this.columns && this.graph[r+2][c+2] == '.'){
                HoppersConfig successor = new HoppersConfig(this);
                if (this.graph[r+1][c+1] == 'G'){
                    successor.graph[r+1][c+1] = '.';
                    successor.pieceCount -= 1;
                    successor.graph[r+2][c+2] = this.graph[r][c];
                    successor.graph[r][c] = '.';
                    moves.add(successor);
                }
            }

        } else {
            //only 4 moves that can be made
            //
            //top left jump
            if (r-2 >= 0 && c-2 >= 0 && this.graph[r-2][c-2] == '.') {
                HoppersConfig successor = new HoppersConfig(this);
                if (this.graph[r - 1][c - 1] == 'G') {
                    successor.graph[r - 1][c - 1] = '.';
                    successor.pieceCount -= 1;
                    successor.graph[r - 2][c - 2] = this.graph[r][c];
                    successor.graph[r][c] = '.';
                    moves.add(successor);
                }
            }
            //top right jump
            if (r-2 >= 0 && c+2 < this.columns && this.graph[r-2][c+2] == '.'){
                HoppersConfig successor = new HoppersConfig(this);
                if (this.graph[r-1][c+1] == 'G') {
                    successor.graph[r - 1][c + 1] = '.';
                    successor.pieceCount -= 1;
                    successor.graph[r - 2][c + 2] = this.graph[r][c];
                    successor.graph[r][c] = '.';
                    moves.add(successor);
                }
            }
            //bottom left jump
            if (r+2 < this.rows && c-2 >= 0 && this.graph[r+2][c-2] == '.'){
                HoppersConfig successor = new HoppersConfig(this);
                if (this.graph[r+1][c-1] == 'G'){
                    successor.graph[r+1][c-1] = '.';
                    successor.pieceCount -= 1;
                    successor.graph[r+2][c-2] = this.graph[r][c];
                    successor.graph[r][c] = '.';
                    moves.add(successor);
                }
            }
            //bottom right jump
            if (r+2 < this.rows && c+2 < this.columns && this.graph[r+2][c+2] == '.'){
                HoppersConfig successor = new HoppersConfig(this);
                if (this.graph[r+1][c+1] == 'G'){
                    successor.graph[r+1][c+1] = '.';
                    successor.pieceCount -= 1;
                    successor.graph[r+2][c+2] = this.graph[r][c];
                    successor.graph[r][c] = '.';
                    moves.add(successor);
                }
            }
        }
        return moves;
    }

    /**
     * checks to see if a square on the grid contains a frog
     * @return true or false
     */
    public boolean isFrog(int row, int col){
        return graph[row][col] == 'R' || graph[row][col] == 'G';
    }

    /**
     * Checks to see if a row has an odd amount of available spaces. Used in generating moves
     * @param row row of the graph
     * @return true or false
     */
    public boolean isOddRow(int row){
        int availableSpaces = 0;
        for (int c = 0; c < columns ; c++){
            if(graph[row][c] == '.'){
                availableSpaces += 1;
            }
        }
        return availableSpaces % 2 != 0;
    }

    /**
     * takes the Hoppers Config and turns it into its string representation
     * @return the printed version of the 2D array
     */
    @Override
    public String toString(){
        StringBuilder result = new StringBuilder("");
        for (int r = 0; r < rows; r++){
            for(int c = 0; c < columns; c++){
                if (c == columns-1){
                    result.append(this.graph[r][c]).append(System.lineSeparator());
                } else{
                    result.append(this.graph[r][c]).append(" ");
                }
            }
        }

        return result.toString();
    }

    /**
     * equals method for the config to be used in the solver
     * @param o other config
     * @return whether they are equal or not
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        HoppersConfig that = (HoppersConfig) o;
        return Arrays.deepEquals(graph, that.graph);
    }

    /**
     * hashcode method for the config. used in the solver
     * @return
     */
    @Override
    public int hashCode() {
        return Arrays.deepHashCode(graph);
    }

    /**
     * getter method for rows
     * @return amount of rows in config
     */
    public int getRows(){
        return rows;
    }

    /**
     * getter method for columns
     * @return amount of columns in config
     */
    public int getColumns(){
        return columns;
    }

    public char[][] getGraph() {
        return graph;
    }
}
