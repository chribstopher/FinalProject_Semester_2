package puzzles.hoppers.model;

import puzzles.common.solver.Configuration;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

// TODO: implement your HoppersConfig for the common solver

public class HoppersConfig implements Configuration{
    private static int rows;
    private static int columns;
    private char[][] graph;
    private int pieceCount;
    private int col;
    private int row;

    public HoppersConfig(String filename) throws IOException {
        try (BufferedReader in = new BufferedReader(new FileReader(filename))){
            //getting rows and column dimensions
            String[] dimensions = in.readLine().split("");
            this.rows = Integer.parseInt(dimensions[0]);
            this.columns = Integer.parseInt(dimensions[1]);
            this.graph = new char[rows][columns];
            //building the graph
            //piece count will be used for isSolution
            this.pieceCount = 0;
            for (int r = 0; r < rows; r++){
                String[] rowContents = in.readLine().split("");
                for (int c = 0; c < columns; c++){
                    char content = rowContents[c].charAt(0);
                    if (content == 'G' || content == 'R'){
                        this.pieceCount += 1;
                    }
                    this.graph[r][c] = content;
                }

            }
        }
    }

    /**
     * Copy constructor. Takes a config other, and makes a full copy of its
     * instance data
     * @param other the config to copy
     */
    private HoppersConfig(HoppersConfig other){
        this.rows = other.rows;
        this.columns = other.columns;
        this.graph = new char[rows][columns];
        this.pieceCount = other.pieceCount;
        //copying other graph
        for (int r = 0; r < rows; r++){
            for (int c = 0; c < columns; c++){
                this.graph[r][c] = other.graph[r][c];
            }
        }
    }

    /**
     * checks if the current configuration is the solution
     * @return true or false
     */
    @Override
    public boolean isSolution() {
        return this.pieceCount == 1;
    }

    /**
     * finds all the neighbor configurations for a given configuration
     * @return collection of all the neighbors
     */
    @Override
    public Collection<Configuration> getNeighbors() {
        List<Configuration> neighbors = new ArrayList<>();
        for (int r = 0; r < rows; r++){
            boolean oddRow = isOddRow(r);
            for (int c = 0; r < columns; c++){
                if (isFrog(r, c)){
                    List<Configuration> moves = getMoves(r, c, oddRow);
                    //after the list is gotten maybe just add it to the neighbors?
                    //will have to see after get moves is made.
                }
            }
        }

    }

    /**
     * finds which moves can be generated by a given frog
     * @return collection of configurations representing valid moves
     */
    public List<Configuration> getMoves(int r, int c, boolean oddRow){
        List <Configuration> moves = new ArrayList<>();
        if (oddRow){
            //8 moves that can be made
            //
            //top left jump
            if (r-2 >= 0 && c-2 >= 0 && this.graph[r-2][c-2] == '.'){
                HoppersConfig successor = new HoppersConfig(this);

                //validate or sum idk
                //if possible move, add to moves list
            }
            //north jump
            if (r-2 >= 0 && this.graph[r-2][c] == '.'){
                //validate??
                //if possible move, add to moves list
            }
            //top right jump
            if (r-2 >= 0 && c+2 < this.columns && this.graph[r-2][c+2] == '.'){
                //validate
                //if possible move, add to moves list
            }
            //west jump
            if (c-2 >= 0 && this.graph[r][c-2] == '.'){
                //validate
                //if possible move, add to moves list
            }
            //east jump
            if (c+2 < this.columns && this.graph[r][c+2] == '.'){
                //validate
                //if possible move, add to moves list
            }
            //bottom left jump
            if (r+2 < this.rows && c-2 >= 0 && this.graph[r+2][c-2] == '.'){
                //validate
                //if possible move, add to moves list
            }
            //south jump
            if (r+2 < this.rows && this.graph[r+2][c] == '.'){
                //validate
                //if possible move, add to moves list
            }
            //bottom right jump
            if (r+2 < this.rows && c+2 < this.columns && this.graph[r+2][c+2] == '.'){
                //validate
                //if possible move, add to moves list
            }

        } else {
            //only 4 moves that can be made
        }
        return null;
    }


    /**
     * checks to see if a given configuration is valid and if not,
     * prunes the configuration.
     * @return true or false
     */
    public boolean isValid(int r, int c){
        //checks if a frog has been jumped over. if there is no frog to jump over, the move
        //isn't valid. if there is a frog, check if it is red or green. If the frog is green,
        //the config is valid and that one can be removed. If the frog is red, the move is not valid.
        return false;
    }

    /**
     * checks to see if a square on the grid contains a frog
     * @return true or false
     */
    public boolean isFrog(int row, int col){
        return graph[row][col] == 'R' || graph[row][col] == 'G';
    }

    /**
     * Checks to see if a row has an odd amount of available spaces. Used in generating moves
     * @param row row of the graph
     * @return true or false
     */
    public boolean isOddRow(int row){
        int availableSpaces = 0;
        for (int c = 0; c < columns ; c++){
            if(graph[row][c] == '.'){
                availableSpaces += 1;
            }
        }
        return availableSpaces % 2 != 0;
    }
}
